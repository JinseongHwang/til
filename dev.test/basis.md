# 테스트를 작성할 때 마음 가짐

## 테스트 코드 작성할 때 주의할 점

- 테스트를 비결정적으로 작성하지 않는다.
  - 테스트를 실행할 때마다 결과가 달라지는 형태는 테스트 신뢰도를 낮출 수 있다.
- 커버리지에 집착하지 않는다.
  - 테스트 자체의 효용에 집중해야 한다. 커버리지 자체에 집중하면 커버리지를 위한 테스트 코드로 변질될 수 있다.

## 레거시 코드에 테스트 코드를 추가해서 얻을 수 있는 것

- 회귀 버그 방지 : 예전에 잘 동작하던게 신규 배포로 인해 잘 동작하지 않는 현상을 방지할 수 있다.
- 유연한 설계로 개선 : 
  - 테스트를 쉽게 만들어 줌
  - 비결정적 테스트를 결정적으로 만들어 줌
- **결론: 레거시 코드에 테스트 코드를 추가할 땐 필히 설계 개선과 함께 이루어져야 한다.**

## 테스트가 보내는 신호를 잘 잡아야 한다

- 테스트를 작성하다 보면, 테스트 작성하기 정말 곤란한 경우가 있다. 테스트 프레임워크에 대한 이해도가 낮은 게 아니라면 설계를 개선해야 할 신호일 가능성이 높다.
- 테스트 그냥 통과 시킬려고 mock 프레임워크 가져다 붙이면 신호를 무시하고 지나칠 수도 있다. 나중에 더 개선하기 힘든 상황이 찾아올 수도 있다.
- 두루뭉실하게, 테스트가 보내는 신호는 다음과 같은 것들이 있다.
  - 무의미한 테스트
  - 느리고 쉽게 깨지는 테스트
  - 테스트가 불가한 코드

## 테스트의 필요성

- "내게 레거시 코드란, 단순히 테스트 루틴이 없는 코드다. 다만 이 정의는 다소 불완전하다." - 레거시 코드 활용 전략, 마이클 페더스
- Regression(회귀) 버그를 테스트로 극복할 수 있다.
- 테스트를 작성하다 보면 좋은 아키텍처로 개선되곤 한다.
  - 테스트 코드는 SOLID와 굉장히 긴밀한 관계를 가진다.
  - SOLID가 잘 지켜지면 객체 간 경계가 생기고, 경계를 구분해서 테스트 코드가 작성되어야 비로소 회귀 버그를 방지할 수 있다.
- **결론: 좋은 설계도 놓치면 안되고 SOLID도 놓치면 안된다.**

## private 메서드도 테스트 해야할까?

- https://shoulditestprivatemethods.com/
- NO
- Every time you consider testing a private method, your code is telling you that you haven't allocated responsibilities well.  Are you listening to it?

## DRY와 DAMP

테스트 코드에서는 DRY 보단 DAMP가 적절하다

- DRY : Don't Repeat Yourself
  - 코드를 반복하지 마라!
- DAMP : Descriptive And Meaningful Phrase
  - 서술적이고 의미있는 문구
  - 테스트 코드에서는 코드 중복이 있더라도 가독성을 신경 써라!

# 테스트의 3분류

## 전통적인 테스트 피라미드

전통적인 테스트는 다음과 같이 3단계로 분류된다.
1. Unit test (단위 테스트)
2. Integration test (통합 테스트)
3. E2E test (API 테스트)

하지만 이는 잘 와닿지 않는다.  
단위 테스트에서 말하는 단위는 메서드인가? 클래스인가? 패키지인가? API인가? 서버인가?  
통합 테스트도 뭘 통합한다는 것인지 명확하지 않다. 왜 API 테스트가 통합 테스트보다 상위 그룹에 있는지도 와닿지 않는다.  
이를 "구글 엔지니어는 이렇게 일한다" 책에서는 아래와 같이 구분한다.

## 구글의 테스트 피라미드

1. Small test
2. Medium test
3. Large test

**Small test**  
제약 조건  
- 단일 서버
- 단일 프로세스
- 단일 스레드
- Disk I/O 사용해선 안됨
- Blocking call 허용하면 안됨

특징
- 테스트가 결정적이다.
- 속도가 빠르다.

**Medium test**  
제약 조건
- 단일 서버
- 멀티 프로세스
- 멀티 스레드

특징
- H2같은 테스트용 DB를 사용할 수 있게 된다.
- 테스트가 결정적이지 않을 수 있다. 외부 모듈(H2)에 의존하는 경우가 생기기 때문이다.

**Large test**  
제약 조건
- 멀티 서버
- (없음)

특징
- E2E 테스트

이상적인 비율은 Large : Medium : Small = 5 : 15 : 80 이다.  
즉, 우리는 Small test에 가장 집중해야 한다.

# 엔티티

### 도메인 엔티티

- 소프트웨어에서 어떤 도메인이나 문제를 해결하기 위해 만들어진 모델
- 비즈니스 로직을 들고 있고, 식별 가능하며, 일반적으로 생명 주기를 갖는다.

### DB 엔티티

- 데이터베이스 분야에서 개체 또는 엔티티라고 하는 것은 데이터베이스에 표현하려고 하는 유형, 무형의 객체로써 서로 구별되는 것을 뜻한다.
- 쉽게 말해, RDB에 저장되는 객체를 의미한다. 

### 영속성 객체

- 도메인 엔티티와 DB 엔티티는 서로 다르지만, 유사한 성격을 띈다. 유사한 것들을 함께 어울리게 하기 위해 ORM이 등장한다.
- ORM을 통해 관계형 DB의 DB 엔티티를 객체로 매핑해주는 것이 영속성 객체이다.

### 결론

- 개발 세계에서 쓰이는 "엔티티"는 도메인 엔티티이며, 이는 JPA와 상관 없는 표현이다.
- 도메인 엔티티(class)에 JPA의 @Entity를 무조건 붙이는 것은 지양해야 한다. 이는 서비스가 RDB에 지나치게 의존하도록 만든다.
- ORM은 RDB 전용이고, DocumentDB(ex. MongoDB)를 위한 ODM도 있다. 언제든 변화에 대응하는 것이 중요하다.
