## Lambda 왜 써?

1. 코드 실행 시간만큼만 (잘만 사용하면) 비용이 굉장히 저렴함!
2. 서버 관리? 스케일아웃? 고가용성? 그딴거 신경 안써도 됨. 코딩에만 집중하면 됨.
3. (특히 EDA 구축할 때) 다른 AWS 컴포넌트 들이랑 궁합이 좋다.
4. (비교적) 배포 난이도가 낮음.
5. Node.js, Java, Python, Go, Ruby, C# 등 점유율 높은 언어들 지원함.

## Lambda 실행 환경

- 람다 실행 환경은 핸들러 내부, 핸들러 외부(pre-handler)로 구분된다.
- 핸들러 내부 : 핵심적인 비즈니스 로직
- 핸들러 외부 : DB connection pool 등은 더 길게 유지가 필요한 부분
    - RDS Proxy + Pre-Handler 통해서 DB Connection을 유지할 수 있다.

## Lambda 동기 or 비동기

- 동기: 람다 트리거 이벤트가 발생하면, 함수 수행 후 결과를 바로 클라이언트에게 응답하는 방식
- 비동기: 람다 트리거 이벤트가 발생하면, 일단 200 OK 내려주고, 콜백이 다른 것들을 트리거 하는 방식 (뭔가 실패하면 DLQ에 넣고 재시도 하거나 성공 결과를 슬랙, 메일로 전송한다거나...)

## Lambda 비용

- 실행 시간, 요청 수, 사용 메모리 크기로 결정된다.
- 하... 어렵다. 하지만 걱정할 필요 없다.

## Lambda 성능 vs 비용 최적치 알아내기

- Lambda Power Tuning 을 사용하면 성능, 비용 대비 최적치를 알려준다.
- https://github.com/alexcasalboni/aws-lambda-power-tuning
    - AWS에서 공식적으로 밀어주는 프로젝트이다.

## 프로비저닝 컨텍스트는 어디에 저장되고 얼마나 유지되는가?

- 비공적인 내용임!
    - S3에 저장된다.
    - 약 15분 간 유지된다.

## JVM Function은 쓸만한가?

- Java같은 경우는 콜드 스타트에 1초 이상이 걸릴 수도 있다.
- 하지만 Snap start 라고 스냅샷을 뜨는 방식이 생겼다. 따라서 콜드 스타트가 굉장히 크게 개선됐다.
    - 디스크의 상태를 Firecracker microVM Snapshot으로 저장해둔다.
    - Java의 경우 JIT 컴파일러가 더 많은 코드를 컴파일 하면 Snap start 성능이 더 좋아지는데, crac 등의 라이브러리를 사용해서 개선 가능하다.