## 궁금증

CPU 코어는 왜 한 번에 스레드 1개씩만 처리 가능할까?

## CPU 실행 파이프라인 (간단히)

CPU에선 아래 과정이 순차적으로 실행된다.
1개의 명령어가 실행되는 것이고, 이를 `1 cycle` 로 표현하기도 한다.

1. Fetch: PC가 가리키는 주소에서 명령어 가져와서 PC Register에 저장한다.
2. Decode: 명령어 해석한다.
3. Execute: 명령어 실행한다.
4. Memory: (필요 시) 메모리에서 읽기 or 메모리에 쓰기
5. Writeback: 명령어 실행 결과를 레지스터/메모리에 기록한다.

## CPU 구조

먼저 CPU에 어떤 정보가 저장되고 처리되는지 알아보자.
일단 CPU 구성 요소는 크게 3가지가 있다.

### 1. Control Unit (CU)

말 그대로 CPU를 제어하는 장치이다. 기억 장치(ROM; CPU 내부 저장장치)에서 프로그램 명령어를 순차적으로 꺼내 해석하고, 어떤 작업을 수행해야 하는지 결정한다.

**CU의 구성 요소**

1. PC (Program Counter)
- 현재 실행 중인 프로그램의 다음 명령어 위치를 가리키는 레지스터이다.
- CPU 실행 과정 중 Fetch 단계에서, 지금 실행할 명령어를 가져온 후 IR에 저장하고 다음 실행할 명령어의 메모리 주소를 PC에 다시 기록한다.
    - 명령어 크기만큼 PC 자동 증가시킨다. 예를 들어 주소 단위가 1byte이고 명령어 크기가 4byte라면, 현재 0x100 실행 시 다음은 0x104 기록한다. 그 다음 명령어가 8byte 명령어라면 0x10C 로 변경한다.
    - 분기 명령(jump, call) 시 PC 값이 새 주소로 변경된다.

2. MAR/MDR
- 메모리 주소 레지스터, 메모리 데이터 레지스터이다.
- 메모리에 엑세스 할 주소, 메모리에서 읽어온 데이터, 메모리에 쓸 데이터 등을 저장하는 임시 저장소이다.

3. IR
- 명령어(Instruction) 레지스터이고 현재 실행 중인 명령어를 저장한다.
- CPU는 IR에 저장된 명령어를 디코딩하고 실행한다.

4. Control Block
- 제어 블록은 명령어 실행, 레지스터 간 데이터 이동, 연산 수행 등 CPU의 다양한 기능을 조절하고 동기화하는 역할을 수행한다.

### 2. ALU

명령어를 실행하기 위한 산술 및 논리 연산을 수행하는 역할이다.
입력에 대해 어떤 연산을 수행할지, 모두 CU를 통해 전달받아 처리한다.

**동작 과정**

1. 입력 2개를 받아서
2. 어떤 연산을 수행할지 결정하고 (CU에서 제어 신호 받아서 결정)
3. Adder, Subtractor, AND, OR, XOR, Shifter, Comapator 등의 논리 연산을 수행하고
4. 결과를 레지스터에 저장하거나 다음 단계로 전달한다. 
    - 상태 플래그도 함께 저장하거나 전달한다.

**어셈블리 동작 예시**

```asm
; ADD RAX, RBX  (RAX = RAX + RBX)
```

1. CU가 ADD 연산 선택 신호를 ALU에 전달
2. 레지스터 파일에서 RAX 값 -> ALU 입력 A로
3. 레지스터 파일에서 RBX 값 -> ALU 입력 B로
4. ALU 내부 Adder가 A + B 계산
5. 결과를 RAX에 저장
6. 상태 플래그 업데이트 (결과가 0이면 ZF=1, 오버플로우 시 OF=1 등)

참고로 RAX, RBX는 범용 레지스터에 있는 저장소 종류이다
- RAX : 계산 결과 저장용
- RBX : 베이스 주소 저장용

### 3. Register (Reg)

레지스터는 CPU 내부에 있는 소규모 고속 기억 장치이다.
명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장한다.
L1/L2/L3 보다 상위에 존재하며, 보통 1 cycle 에 필요한 데이터만 저장한다.
목적에 따라 범용 레지스터와 특수 목적 레지스터로 구분된다.

(자세한 건 Pass)

## CPU 실행 파이프라인 (자세히)

CPU 실행 파이프라인을 어셈블리 코드 예시와 함께 좀 더 자세히 살펴보자.

**어셈블리 동작 예시**

```asm
; ADD RAX, RBX  (RAX = RAX + RBX)
```

1. IF (Instruction Fetch)
    - PC에 0x104 값이 저장되어 있다고 가정.
    - 메모리의 0x104 주소에서 명령어를 읽어 IR에 저장
    - PC = PC + 4 (0x104 주소의 명령어 크기가 4byte라면, 4만큼 증가시켜 다음 명령어 주소로 이동시킨다)

2. ID (Instruction Decode)
    - IR에 저장된 기계어를 분석하여 어떤 동작인지 파악
        - Opcode: 수행할 작업 (ADD)
        - Source1: RAX 레지스터
        - Source2: RBX (메모리)
        - Destination: RBX (메모리)
    - 레지스터 파일에서 RAX, RBX 값 읽기

3. EX (Execute)
    - ALU를 통해 실제 계산을 수행
        - 메모리에서 읽은 RBX 값 + RAX 값
    - 산술 연산 결과와 함께 CPU의 상태를 나타내는 Flag를 생성

4. MEM (Memory Access)
    - 명령어에 따라 메모리에 데이터를 쓰거나(Store), 메모리로부터 데이터를 읽음(Load).
        - Store: 레지스터 -> 메모리
        - Load: 메모리 -> 레지스터
    - 이 단계는 메모리 참조가 필요한 명령어일 때만 활성화됨

5. WB (Write Back)
    - 최종 연산 결과를 목적지 레지스터나 메모리에 기록
    - 상태 플래그 레지스터(RFLAGS)를 갱신하여 다음 명령 진행 시 참고하도록 한다

## C언어 코드 한 줄이 실행되려면?

```c
int result = a + b;
```

1. 컴파일러가 기계어로 변환
```asm
MOV  EAX, [a]      ; 변수 a를 EAX 레지스터로 로드
MOV  EBX, [b]      ; 변수 b를 EBX 레지스터로 로드
ADD  EAX, EBX      ; EAX = EAX + EBX
MOV  [result], EAX ; 결과를 메모리에 저장
```
2. 명령어 1: `MOV EAX, [a]`
- IF: PC가 가리키는 주소에서 명령어 fetch
- ID: "메모리에서 EAX로 로드하라"고 해석
- EX: 주소 계산 (a의 메모리 주소)
- MEM: L1 캐시 확인 → 없으면 L2 → L3 → RAM
- WB: 읽은 값을 EAX에 저장
3. 명령어 2: `MOV EBX, [b]`
- 명령어 1과 동일함. 파이프라이닝으로 명령어 1과 동시 진행 가능
    - 파이프라이닝: 실제 명령어 1개 실행이 5단계로 쪼개져있는데, 5단계 다 끝나기 전에 다음 명령어 단계를 시작하는 걸 의미함.
    - CPU가 시분할해서 여러 작업을 나눠서 실행하는 것과 일맥상통함
4. 명령어 3: `ADD EAX, EBX`
- EX 단계에서 ALU가 덧셈 수행
- WB에서 결과를 EAX에 저장, RFLAGS 업데이트
5. 명령어 4: `MOV [result], EAX`
- MEM 단계에서 결과를 메모리(캐시)에 기록

## 질문에 대한 해답

질문: CPU 코어는 왜 한 번에 스레드 1개씩만 처리 가능할까?

1. 싱글코어 CPU는 물리적으로 ALU, Register, Control Unit이 각각 하나씩만 존재하기 때문에, 어느 한 클럭 사이클에 Fetch -> Decode -> Execute -> Writeback 할 수 있는 명령어 흐름(스레드)은 딱 하나뿐이다.
2. 멀티스레드 환경에서 여러 스레드가 동시에 실행되는 것처럼 보이는 건, OS 스케줄러가 타이머 인터럽트마다 현재 스레드의 PC, Register 들의 상태를 TCB에 저장하고 다른 스레드의 상태를 복원하는 걸 (Context Switching) 수 밀리초 단위로 반복하기 때문이다.