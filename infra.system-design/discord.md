## 디스코드 시스템 디자인

### 초기
- 초기 버전은 2달만에 제작됐고, 2015년에 출시됐다.
- 실시간 메시징 시스템에는 Elixir를 사용했고, API 서버에는 Python을 사용했다.
  - Elixir는 ErlangVM 기반으로 동작한다. 마치 Java가 JVM 기반으로 동작하는 것과 유사하다.
  - Erlang은 전 세계 GPRS, 3G, LTE 모바일 네트워크를 구축하는 데 사용되고 있다.
  - Erlang은 견고하고 레이턴시가 짧고, 분산된 내결함성 시스템을 지원하도록 설계됐다.
  - Elixir언어로 사용할 수 있는 Phoenix라는 웹 프레임워크도 있다!
  - ErlangVM은 코어 별로 스케줄러를 가지고 있으며, 스케줄러에 Task가 하나씩 할당되어 동작한다. Task를 스케줄러에 할당하는 것인 ErlangVM 내부의 Load Balancer가 수행한다. 이러한 방식으로 Erlang/Elixir는 동시성과 병렬성을 가질 수 있다.
- 초기에는 MongoDB를 사용했다. 빠른 반복 작업에 가장 적합할 것이라고 판단했다.

### 1억개의 메시지가 쌓이고 난후
- MongoDB에 데이터와 인덱스를 저장하기에 메모리가 부족한 이슈가 생겼다.
- CassandraDB로 마이그레이션을 진행한다. replica factor=3으로 설정하고 총 12개의 노드로 구성된 클러스터로 구축해서 사용했다. 각 노드의 크기는 1TB정도였다.
- 2022년에는 177개의 노드까지 늘어났고, 각 노드는 평균적으로 4TB의 크기로 늘어났다.
- 각 노드는 버킷이라는 단위로 쪼개져서 저장된다. 각 버킷은 연관성이 높은 데이터로 묶여서 저장됐다. 지역성을 높여서 읽기 성능을 올리기 위함이었다. 예를 들어, 같은 날에 발생한 메시지는 같은 버킷에 저장됐다.
- Cassandra는 읽기 연산이 쓰기 연산보다 비싸다! 피크 타임에 같은 버킷(파티션)으로 읽기 연산이 몰리면 느려질 수 밖에 없다. 요청이 몰린 파티션을 "Hot partition"이라고 부른다. Hot partition이 포함됐다면 그 노드 전체의 속도가 느려지게 된다.

### Data service의 도입
- Hot partition 문제를 해결하기 위해 Data service를 도입했다. Data service는 요청과 파티션 사이에 존재하는 새로운 컴포넌트의 이름이다.
- Data service는 Rust로 개발됐다.
- 데이터베이스의 과부하를 막는 역할이다.
- Data service는 Request coalescing이라는 기능을 수행하는데, 여러 유저가 동일한 조회 쿼리를 날리면 Data service는 실제 DB에게 1개의 쿼리만 수행되도록 한다.
  - 예를 들어, 어떤 유저가 공지 메시지를 @everyone 태그를 걸고 메시지를 보냈다면 여러 유저가 동시에 그 메시지를 조회할 것이다.
  - Data service가 없었다면 DB에는 유저 수만큼의 조회 쿼리가 발생했을테지만
  - Data service가 해당 조회 쿼리들을 모아서 단 한번만 수행하도록 조정하기 때문에 실제 DB에는 하나의 쿼리만 들어간다.
  - 따라서 Hot partition 문제가 발생하지 않는다.

## Cassandra에서 Scylla로 마이그레이션
- Data service의 도입으로 Hot partition 빈도가 많이 줄었지만, 여전히 계속해서 발생했다.
- Cassandra에서 Scylla로 마이그레이션을 진행하기로 결정한다.
  - ScyllaDB는 C++로 작성된 Cassandra 호환 DB이다.
  - Cassandra는 Java로 작성되어 있기 때문에 GC 과정에서 지연 문제가 있었는데, Scylla에서는 그 문제가 해결됐다.
- Scylla 에서 제공되는 오픈소스 Migrator를 사용하면 수조개의 메시지를 마이그레이션 하는데 3개월의 시간이 걸릴 것으로 예상됐다.
- Rust로 Migrator를 다시 만들고, SQLite의 체크포인트를 사용해서 9일만에 마이그레이션이 완료되도록 했다.
- 마이그레이션 이후, 더 이상 Hot partition 문제는 발생하지 않게 됐다.
- 177개의 노드를 운영해야 했던 Cassandra에서, 마이그레이션 이후에는 Scylla는 72개의 노드만 운영하면 됐다.
- 각 Scylla의 노드는 9TB이다.
- 읽기와 쓰기 속도가 수배 개선됐으며, 읽기와 쓰기 속도로 일정하게 나온다.