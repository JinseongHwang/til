## 개요

인덱스에 문서를 색인, 조회, 업데이트, 삭제하는 방법을 알아보자.

## 단건 문서 API

### 색인 API
- 사용 방법: `PUT` 또는 `POST` 메서드를 사용하여 문서를 색인합니다. `_doc` 엔드포인트를 통해 문서를 추가하거나 `_create`를 통해 새 문서를 생성할 수 있습니다.
- 쿼리 예시:
  ```json
  PUT /index_name/_doc/1
  {
    "title": "Elasticsearch Basics",
    "content": "Elasticsearchhhhhh."
  }
  ```
- 주의 사항: 
  - `_doc` 메서드는 지정된 ID로 문서를 저장하며, 이미 존재하는 경우 덮어씁니다.
  - `_create` 메서드는 자동으로 새로운 ID를 생성하여 문서를 추가합니다.
  - 대량의 문서를 색인할 경우, 성능 저하가 발생할 수 있으므로 배치 색인(Bulk API)을 고려해야 합니다.

### 조회 API
- 사용 방법: `GET` 메서드를 사용하여 문서를 조회합니다. `_doc` 엔드포인트를 통해 특정 ID의 문서를 가져올 수 있으며, `_source`를 통해 문서의 원본 소스를 확인할 수 있습니다.
- 쿼리 예시:
  ```json
  GET /index_name/_doc/1
  ```
- 주의 사항: 
  - 대량의 조회 요청은 클러스터의 성능에 영향을 줄 수 있으므로, 캐싱을 활용하거나 필요한 필드만 조회하는 것이 좋습니다.
  - 실시간성이 중요한 경우, 조회 속도를 높이기 위해 필요한 설정을 조정할 수 있습니다.

### 업데이트 API
- 사용 방법: `POST` 메서드를 사용하여 문서를 업데이트합니다. `_update` 엔드포인트를 통해 부분 업데이트를 수행할 수 있습니다.
- 쿼리 예시:
  ```json
  POST /index_name/_doc/_update/1
  {
    "doc": {
      "content": "Elasticsearchhhhhh."
    }
  }
  ```
- 주의 사항: 
  - 업데이트는 문서를 읽고 수정한 후 다시 색인하는 과정을 포함하므로, 빈번한 업데이트는 성능에 영향을 미칠 수 있습니다.
  - 스크립트를 사용하여 복잡한 업데이트를 수행할 수 있지만, 스크립트의 복잡도는 성능에 영향을 줄 수 있습니다.

### 삭제 API
- 사용 방법: `DELETE` 메서드를 사용하여 문서를 삭제합니다. `_doc` 엔드포인트를 통해 특정 ID의 문서를 삭제할 수 있습니다.
- 쿼리 예시:
  ```json
  DELETE /index_name/_doc/1
  ```
- 주의 사항: 
  - 삭제 작업은 즉시 반영되지 않으며, 백그라운드에서 수행됩니다. 따라서, 삭제 후 즉시 조회 시 결과가 남아 있을 수 있습니다.
  - 대량의 삭제 작업은 성능에 영향을 미칠 수 있으므로, 필요한 경우 배치 삭제(Bulk API)를 고려해야 합니다.

## 검색 API

### 검색 대상 지정
- **사용 방법**: `GET` 또는 `POST` 메서드를 사용하여 `_search` 엔드포인트로 요청을 보냅니다. 
- **예제**:
  ```json
  GET /index_name/_search
  {
    "query": {
      "match_all": {}
    }
  }
  ```   
- **주의 사항**:
  - `GET` 메서드는 URL에 쿼리를 포함할 수 있지만, 긴 쿼리는 `POST` 메서드를 사용하는 것이 좋습니다.
  - `_search` 요청은 기본적으로 모든 샤드에서 실행되므로, 대량의 데이터에 대해 검색할 경우 성능에 주의해야 합니다.

### 쿼리 문맥과 필터 문맥
- **설명**:
  - 쿼리 문맥은 점수 기반으로 문서를 검색합니다. (e.g., `match`, `term`)
  - 필터 문맥은 점수와 관계없이 문서를 필터링합니다. (e.g., `range`, `exists`)
- **예제**:
  ```json
  {
    "query": {
      "bool": {
        "must": {
          "match": { "field": "value" }
        },
        "filter": {
          "term": { "status": "active" }
        }
      }
    }
  }
  ```
- **주의 사항**:
  - 필터는 캐싱되어 성능에 유리하며, 점수 계산이 필요 없는 경우 필터를 사용하는 것이 좋습니다.

### 쿼리 수행 순서
- **설명**: `bool` 쿼리를 사용하여 여러 조건을 조합합니다.
- **예제**:
  ```json
  {
    "query": {
      "bool": {
        "must": [
          { "match": { "title": "search" } }
        ],
        "should": [
          { "match": { "content": "elasticsearch" } }
        ],
        "must_not": [
          { "term": { "status": "inactive" } }
        ]
      }
    }
  }
  ```
- **주의 사항**:
  - `must`는 필수 조건, `should`는 선택 조건, `must_not`은 제외 조건을 의미합니다.
  - `should` 조건이 여러 개일 때는 `minimum_should_match`를 설정하여 최소 만족 개수를 지정할 수 있습니다.

### 검색 결과 정렬
- **사용 방법**: `sort` 파라미터를 사용하여 결과를 정렬합니다.
- **예제**:
  ```json
  {
    "sort" : [
        { "post_date" : {"order" : "asc", "format": "strict_date_optional_time_nanos"}},
        { "name" : "desc" },
        { "age" : "desc" },
        "_score"
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
  }
  ```
- **주의 사항**:
  - 정렬 필드는 인덱스 시 설정된 `fielddata`를 사용하므로, 메모리 사용량에 주의해야 합니다.
  - 대량의 정렬 작업은 성능에 영향을 줄 수 있습니다.

### 페이지네이션
- **사용 방법**: `from`과 `size` 파라미터를 사용하여 페이지네이션을 구현합니다.
- **예제**:
  ```json
  {
    "from": 5,
    "size": 20,
    "query": {
      "match": {
        "user.id": "kimchy"
      }
    }
  }
  ```
- **주의 사항**:
  - `from` 파라미터가 클 경우 성능 저하가 발생할 수 있습니다. `scroll` API를 사용하여 대량의 데이터를 효율적으로 페이징할 수 있습니다.

## 집계

### 메트릭 집계
- **사용 방법**: `avg`, `max`, `min`, `sum` 등의 메트릭 집계를 사용하여 수치 데이터를 분석합니다.
- **예제**:
  ```json
  {
    "aggs": {
      "average_price": { "avg": { "field": "price" } }
    }
  }
  ```
- **주의 사항**:
  - 집계는 전체 데이터를 스캔하므로, 대량의 데이터에 대해 성능에 주의해야 합니다.

### 버킷 집계
- **사용 방법**: `range`, `terms`, `histogram` 등의 버킷 집계를 사용하여 데이터를 그룹화합니다.
- **예제**:
  ```json
  {
    "aggs": {
      "price_ranges": {
        "range": {
          "field": "price",
          "ranges": [
            { "to": 100 },
            { "from": 100, "to": 200 },
            { "from": 200 }
          ]
        }
      }
    }
  }
  ```
- **주의 사항**:
  - 버킷의 수가 많아질 경우 메모리 사용량이 증가할 수 있으므로, 적절한 버킷 크기를 설정하는 것이 중요합니다.

## 서비스 코드에서 엘라스틱서치 클라이언트 이용

### 저수준 REST 클라이언트

- HTTP 요청/응답을 직접 다루며, JSON 형식의 데이터를 주고받습니다.
- 엘라스틱서치의 모든 기능에 접근할 수 있으며, 최신 API 변경 사항을 빠르게 반영할 수 있습니다.
- 가벼운 클라이언트로, 엘라스틱서치의 모든 버전과 호환됩니다.
- 추상화, 고급/편의 기능이 부족하여 직접 구현해야 하는 부분이 많습니다.
- 에러 핸들링 및 요청 최적화 등의 작업이 개발자에게 맡겨집니다.
- RestClient는 Thread-safe 하며, 재사용 가능합니다.

### 고수준 REST 클라이언트

- 저수준 REST 클라이언트를 기반으로 추상화된 클라이언트이며, 더 많은 기능과 편의성을 제공합니다.
- 요청 빌더, 응답 파서 등의 유틸리티를 제공하여 개발 생산성을 높입니다.
- 코드의 가독성과 유지보수성을 높여주며, 자동 Retry, 에러 핸들링 등의 기능을 기본적으로 제공합니다.
- ES 7.15 부터 지원 중단 선언되었고, 자바 클라이언트로 전환이 예정되어 있습니다. 신규 프로젝트에서는 자바 클라이언트를 사용하는 것을 권장합니다.

### 자바 클라이언트

- 엘라스틱서치를 자바 애플리케이션에서 쉽게 사용할 수 있도록 설계된 클라이언트입니다.
- 엄격한 빌더 패턴을 적용해서 FP 방식으로 코드를 작성할 수 있습니다. QueryDSL과 유사한 방식도 지원합니다.
- 아직 완성도가 높지 않아서 고수준 REST 클라이언트와 혼용하는 것을 고려해봐도 좋습니다.

### 고수준 REST 클라이언트와 자바 클라이언트 혼용하기

- 고수준 REST 클라이언트의 편리함과 자바 클라이언트의 최적화를 결합하여 사용할 수 있습니다.
