## CQRS (Command Query Responsibility Segregation) 란?

CQRS는 직역하면 명령(Command)과 쿼리(Query)의 책임 분리이다. 쉽게 말해 CRUD를 분리해보자면, 명령은 CUD 이고 쿼리는 R 을 의미한다.

## CQRS 왜 사용함?

데이터의 상태를 변경하는 쿼리(Command)와 데이터를 조회하는 쿼리(Query)가 서로 다루는 데이터 범위가 다를 때 CQRS 패턴을 사용한다. 도메인이 복잡해지면 명령과 조회가 다루는 데이터 범위가 커지기 시작한다.

간단한 예를 들면, 게시글(post)과 댓글(comment) 데이터가 있는 게시판 서비스가 있다고 가정하자. 피드를 조회하면 여러 게시글과 상위 댓글 일부를 모두 조회해야 한다. 하지만 댓글을 수정할 경우에는 comment 모델에만 접근하면 된다.

CQRS 패턴을 이용하면 목적이 달라서 복잡도가 증가되는 현상을 막을 수 있다. 예를 들어, 명령 부분은 객체지향 모델과 연관지어 편리하게 사용하기 위해 JPA를 사용하고, 조회 부분은 복잡한 조회 쿼리를 수행하기 위해 MyBatis를 사용할 수 있다. MyBatis로 구현되는 복잡한 쿼리를 JPA로 구현했다간 복잡한 코드와 함께 성능 하락이 발생할 수도 있다. 그럼 또 성능을 개선하기 위해 잘 쓰이지 않는 튜닝을 거치게 되고 전반적으로 소프트웨어의 복잡도가 올라간다.

## 코드로 표현하려면 어떻게 하는게 좋을까?

```
명령 : 컨트롤러 -> 서비스 -> 도메인 -> JpaRepository -> DB
조회 : 컨트롤러 -> DTO/DAO -> MyBatis -> DB
```
- 위와 같이 조회 부분은 (간단하다면) 별도의 서비스 로직을 거치지 않고 바로 DB 접근을 해도 된다.
- JPA의 @Subselect 를 사용하면 비교적 간단하게 조회용 도메인 모델을 만들 수 있다. (썩 추천하진 않음)

## 데이터소스도 분리하는게 좋을까?

- RDB는 일반적으로 트랜잭션을 지원한다. 따라서 명령을 처리하기에 적합하다.
- 조회 기능은 평균적으로 NoSQL이 성능이 좋다. 따라서 조회를 처리하기에 적합하다.
  - 그리고 일반적인 웹 서비스는 조회 요청이 압도적으로 많다. 따라서 조회 앞단에 캐시 레이어를 추가하는 것이 좋다. Redis 등의 메모리 기반 스토리지를 사용하는 것이 일반적이다.

물리적으로 분리된 데이터 소스의 데이터를 동기화 하기 위해선 이벤트 기반으로 처리하면 된다. Pub/Sub 모델이나 MQ 등을 활용하는 것이 일반적이다.

## 단점은 없을까?

첫째, 코드 구현량이 많아진다. 도메인 로직이 복잡하고, 많은 트래픽이 나오는 서비스인지 검토해보자. 가벼운 서비스라면 오히려 분리하는 것이 더 큰 비용을 초래할 수도 있다.

둘째, 더 많은 구현 기술이 필요하다. 위에서 언급한 것만 해도 MyBatis, JPA Subselect, NoSQL(MongoDB, Redis, ...) 등을 도입해야 하니 기술적 난이도가 올라간다.

따라서 잘 따져보고 도입하자!!!!!
